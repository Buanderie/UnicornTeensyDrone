//Â©2016 Chang Liu

#ifndef Globle_variables_h
#define Globle_variables_h
//_______________________________
// User Defines
#define SAMPLING_RATE  2500.00f   // micro seconds, 400Hz (remember to change loop_hz)!!!!!
#define LOOP_HZ        400        // loop hz (must change accordingly with Sampling_rate)!!
#define M_QUAD         0.63f      // in kg !!!!!!!!!!!!####### CHECK THIS BEFORE FLIGHT############
#define ARM_LENGTH     240.00f    // in mm 
#define Jx             0.012795f  // in kgxcm2
#define Jy             0.012879f  // in kgxcm2
#define Jz             0.023746f  // in kgxcm2

#define pi             3.1415927f
#define g              9.8f

float QuadCenInVis[4] = {0.0, -0.055, 0.0, 0.075}; // in meter


//__________________________________
// Flags for Finite State Machine
boolean armed, onAir, enableControl = 0;

boolean initialised = 0;
uint8_t initCount = 0;
float lastR22 = 0;

//_____________________________
// Global Objects and Variables
// Serial Ports
HardwareSerial* XBeeSerial          = &Serial3;
HardwareSerial* SpectrumSerial      = &Serial2;
HardwareSerial* FlowSerial          = &Serial1;
// Set the FreeIMU object
FreeIMU my3IMU = FreeIMU();



// Controllers
//____________________________________
// Initial Gain Parameters
// attitude controller gain
float kp[3] = {2600.00, 2800.00, 10.00}; // {2600.00, 2800.00, 10.00}; // x y z   {2400.00, 2400.00, 15.00}; 500 no odroid
float ki[3] = {130.0,   150.0,    0.0};  // {130.0,   150.0,   0.0};  
float kd[3] = {300.00,  400.00,   5.00}; // {320.00,  420.00, 5.00}; // x y z   {530.00,  530.00,  10.00}; 200 no odroid
const float I_cut = 0.5;
const float thrustRampLimit = 500.0; // in gram (500 g allow max)

// position controller gain
float kp_p[3] = {1.6,  0.0,  0.0};  // p  v_cf        X  2.0   0.0  0.0
float kp_i[3] = {0.6,  0.5,  0.0};  // i  velo_thres  X  0.6   0.5  0.0
float kp_d[3] = {7.0, 20.0,  0.0};  // d  ac_d_smoth  X  6.0  20.0  0.0
float kp_a = 4.00;

// velocity controller gain
float kvp[3] = {3.20, 3.20, 8.00}; //x y altitude
float kvi[3] = {0.70, 0.00, 0.00}; //x y altitude
float kvd[3] = {5.00, 5.00, 12.00}; //x y altitude



// Attitude controller Variables
//__________________________________________________
float R[3][3]     = {{1.00,0.00,0.00},{0.00,1.00,0.00},{0.00,0.00,1.00}};
float Rd[3][3]    = {{1.00,0.00,0.00},{0.00,1.00,0.00},{0.00,0.00,1.00}};
float RdOld[3][3] = {{1.00,0.00,0.00},{0.00,1.00,0.00},{0.00,0.00,1.00}};
float DotRd[3][3] = {{0.00,0.00,0.00},{0.00,0.00,0.00},{0.00,0.00,0.00}};
float IErrorR[3]  = {0.00, 0.00, 0.00};           // integral of attitude error
float Omega[3]    = {0.00, 0.00, 0.00};           // Gyro reading in rad/s
float OmegaOld[3] = {0.00, 0.00, 0.00};           // Gyro reading in rad/s
float DotOmega[3] = {0.00, 0.00, 0.00};           // angular acceleration reading in rad/s/s

float AngularAccelD[3] = {0.00, 0.00, 0.00};        // Controller output
float Moment[3]   = {0.00, 0.00, 0.00};                      // required moment after computing inertia
float DeltaT[3]   = {0.00, 0.00, 0.00}; //x,y,z
float thrust[4]   = {0.00, 0.00, 0.00, 0.00}; // expected thrust generated by each axis in gram
float throttle[4] = {0.00, 0.00, 0.00, 0.00}; // expected throttle given to each motor in servo 0-180

float throttleDamp      = 0.00;     // scales down throttle level for smooth takeoff

// Accel Controller
//___________________________________
float accelD[3]     = {0.00, 0.00, 0.00};  // x, y, z (front-left-up) in world frame
float accelD_smt[3] = {0.00, 0.00, 0.00}; 

// Position controller
//___________________________________
float position_timer    = 0.00;
float position_integ[3] = {0.00, 0.00, 0.00};
float posiD[3]          = {0.00, 0.00, 0.00};  // x, y, z (m) in world frame
float posAltiOffset     = 0.00;
int   newMap            = 100;
float pVision_cf[3]     = {0.00, 0.00, 0.00}; // position value after complementary filter
float vVision_cf[3]     = {0.00, 0.00, 0.00}; // velocity value after complementary filter
float SVO_cf_ofset[3]   = {0.00, 0.00, 0.00}; 

// IMU
//___________________________________
float acce[4]        = {0.00, 0.00, 0.00, 0.00}; // rotation invariant body acceleration with respect to earth {0,x,y,z} (front-left-up) in g
float acceSmt[3]     = {0.00, 0.00, 0.00};       // rotation invariant body acceleration with respect to earth {x,y,z}  (front-left-up) in g
float velocityIMU[3] = {0.00, 0.00, 0.00};
float AltiOutput[3]  = {0.00, 0.00, 0.00};       // {verticalVelocity, altitude, gravityCompensationScale}
float q[4]           = {0.00, 0.00, 0.00, 0.00}; // w,x,y,z output from IMU fusion

//float OmegaBufferX[64];
//float OmegaBufferY[64];
uint8_t gyroDelayCounter = 0;
float omega_w[2]     = {0.00, 0.00};  // delayed omega in body frame (world {x-axis, y-axis} compensation)
float omegaDelay_w[2]= {0.00, 0.00}; // delayed gyro omega measurement  in WORLD frame to sync with vision

// RC controller
//____________________________________
float desireAttitude[3]     = {0.00,0.00,0.00};  // rotate angle around body frame axis {x, y,z} (front-left-up)
float desireAttitude_raw[3] = {0.00,0.00,0.00}; 
float throttleLevel         = 0.00;    // altitude command from controller
float throttleLevel_raw     = 0.00;
float accel_user[3]         = {0.00,0.00,0.00};

float Rd_timer_last     = 0.00;
float accel_timer_last= 0.00;
float velo_timer_last = 0.00;

float veloD[3]          = {0.00, 0.00, 0.00};  // x, y, z(altitude) (front-left-up)
float veloDold[3]       = {0.00, 0.00, 0.00};
float DotVeloD[3]       = {0.00, 0.00, 0.00};


// SELFIE
//____________________________________
#define selfie_pin 6
boolean selfie_lock = 0;
float selfie_timer = 0.0;
#define selfieDISARM  0
#define selfieMINSPIN 1
#define selfieACTIVE  2
int selfie_state = selfieDISARM;

// ESC
//___________________________________
float averageThrust = 0.00;
float averageThrust_last = 0.00;
// Thrust limit
#define max_thurst 450.0 // in grams for one motor
                  

// ROS interface
//_____________________________________
float pVision[3]       = {0.00, 0.00, 0.00};
float vVision[3]       = {0.00, 0.00, 0.00};
float vVision_raw[3]   = {0.00, 0.00, 0.00};
float qVision[4]       = {0.00, 0.00, 0.00, 0.00};
float lambdaVision     = 1.00;
float VIbias_accel[3]  = {0.00, 0.00, 0.00};
float init_position[3] = {0.0, 0.0, 0.0};
int8_t vision_available_ = 4;
bool vision_new_measurment_ = 0;
uint16_t odroid_lost_count_ = 0; // counter to check odroid connection lost
#define slamLED 5

// ROS related
float rosStatus = 0.0; // this is used to log the loop time (in microS) of the extremely slow loop (guessed due to ros com) about 0.2s
ros::NodeHandle  nh;
#include "odroidListener.h"
vi_ekf::odroidListener ros_listener;
tf::IMUBroadcaster imu_broadcaster;
#endif
